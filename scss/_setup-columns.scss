//            _
//           | |
//   ___ ___ | |_   _ _ __ ___  _ __  ___
//  / __/ _ \| | | | | '_ ` _ \| '_ \/ __|
// | (_| (_) | | |_| | | | | | | | | \__ \
//  \___\___/|_|\__,_|_| |_| |_|_| |_|___/

$m__: '';
@function m__col-start-to-end($pair, $_...) { @return selector-parse('.#{$m__}col-#{nth($pair, 1)}-#{nth($pair, 2)}'); }
@function m__row-start-to-end($pair, $_...) { @return selector-parse('.#{$m__}row-#{nth($pair, 1)}-#{nth($pair, 2)}'); }

@mixin homework-setup-columns($max-columns: --max-columns()) {

  /*
    TODO: potential name changes:

    --column-count _-> --global-column-count
    mcol --> multi
  */

  // MULTI-COLUMN LAYOUT
  // issues: https://caniuse.com/#feat=multicolumn
  #{base-class('mcol')} {
    column-fill: balance;
    column-width: auto;
    column-count: var(--multi-column-count, 1);
    column-gap: var(--column-gap, var(--ix));
    -webkit-perspective: 1;
    & > * {
      column-span: none;
      break-inside: avoid;
      break-before: auto;
      break-after: auto;
      --local-column-count: calc(var(--column-span, var(--column-count)) / var(--multi-column-count, 1));
    }
  }

  #{base-class('flow')} {
    display: flex !important;
    flex-direction: row;
    flex-wrap: wrap;
    width: calc(100% + var(--column-gap, var(--ix))) !important;
    margin-left: calc(var(--column-gap, var(--ix)) / -2) !important;
    margin-right: calc(var(--column-gap, var(--ix)) / -2) !important;
    margin-top: calc(var(--row-gap, var(--iy)) / -2) !important;
    margin-bottom: calc(var(--row-gap, var(--iy)) / -2) !important;
    & > * {
      flex: 0 0 auto;
      width: 100%;
      min-width: 0%; // https://css-tricks.com/flexbox-truncated-text/
      min-height: 1px;
      background-clip: content-box;
      padding-left: calc(var(--column-gap, var(--ix)) / 2) !important;
      padding-right: calc(var(--column-gap, var(--ix)) / 2) !important;
      padding-top: calc(var(--row-gap, var(--iy)) / 2) !important;
      padding-bottom: calc(var(--row-gap, var(--iy)) / 2) !important;
    }
  }

  #{base-class('grid')} {
    display: grid !important;
    grid-gap: var(--row-gap, var(--iy)) var(--column-gap, var(--ix));
    grid-template-rows: repeat(var(--row-span, var(--row-count, 1)), max-content);
    grid-template-columns: repeat(var(--local-column-count, var(--column-span, var(--column-count))), minmax(0%, 1fr)); // ~= 'min-width: 0%' rule above https://css-tricks.com/flexbox-truncated-text/
    & > * {
      grid-column: span var(--column-span, var(--column-count)) / span var(--column-span, var(--column-count));
      grid-row: span var(--row-span, var(--row-count, 1)) / span var(--row-span, var(--row-count, 1));
    }
  }

  @each $y in map-keys(inner-y-mods()) { .flow-#{$y}, .grid-#{$y} { --row-gap: var(--inner-y-#{$y}); } }

  // make the following props *non-cascading*
  *, ::before, ::after {
    --column-push: initial;
    --column-push-r: initial;
    --column-start: initial;
    --column-end: initial;
    --row-start: initial;
    --row-end: initial;
  }

  // break classes for mcol children
  .br-inside { break-inside: always; }
  .br-before { break-before: always; }
  .br-after { break-after: always; }
  .nobr-inside { break-inside: avoid; }
  .nobr-before { break-before: avoid; }
  .nobr-after { break-after: avoid; }

  // pre-calculations
  $max-column-count: --max-columns();
  $span-pair-list: ();
  $start-pair-list: ();
  $end-pair-list: ();
  @for $end from 2 through ($max-column-count + 1) {
    @for $start from 1 through ($end - 1) {
      $span: ($end - $start);
      $span-pair-list: map-merge($span-pair-list, ($span: append(map-get($span-pair-list, $span) or (), ($start $end))));
      $start-pair-list: map-merge($start-pair-list, ($start: append(map-get($start-pair-list, $start) or (), ($start $end))));
      $end-pair-list: map-merge($end-pair-list, ($end: append(map-get($end-pair-list, $end) or (), ($start $end))));
    }
  }

  /*
$span-pair-list: #{map-inspect($span-pair-list)}
$start-pair-list: #{map-inspect($start-pair-list)}
$end-pair-list: #{map-inspect($end-pair-list)}
  */
  @each $m in join((null), media-keys()) {
    @include m($m) {
      $m__: m-prefix() !global;

      // contexts: solo, flow, mcol; reset: grid
      #{m-base-class('span', false)} {
        max-width: 100%;
        width: calc((99.99999% + var(--column-gap, var(--ix))) * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)) - var(--column-gap, var(--ix)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          width: calc(99.99999% * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('mcol'), '>')} {
          width: initial; // alt: unset
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          width: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{m-base-class('pull', false)},
      #{m-base-class('push', false)} {
        margin-left: calc((99.99999% + var(--column-gap, var(--ix))) * var(--column-push) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-left: calc(99.99999% * var(--column-push) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-left: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{m-base-class('pull-r', false)},
      #{m-base-class('push-r', false)} {
        margin-right: calc((99.99999% + var(--column-gap, var(--ix))) * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-right: calc(99.99999% * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-right: initial; // alt: unset
        }
      }

      // context: grid-only; idea: is there a way to calculate this in flow/solo?
      #{m-base-class('grid')} {
        @at-root #{selector-combine(&, m-base-class('start', false), $cmbn: '>')} {
          grid-column-start: var(--column-start);
        }
        @at-root #{selector-combine(&, m-base-class('end', false), $cmbn: '>')} {
          grid-column-end: var(--column-end);
        }
        @at-root #{selector-combine(&, m-base-class('row-start', false), $cmbn: '>')} {
          grid-row-start: var(--row-start);
        }
        @at-root #{selector-combine(&, m-base-class('row-end', false), $cmbn: '>')} {
          grid-row-end: var(--row-end);
        }
      }

      // // context: mcol-only (doesn't work in FF)
      // #{m-base-class('mcol')} {
      //   & > .#{$m__}span-all {
      //     column-span: all;
      //   }
      // }

      // context: flow-only
      #{m-base-class('flow')} {
        & > .#{$m__}span-auto {
          flex: 1 1 auto;
          --column-span: 0;
        }
      }

      @for $n from 1 through ($max-column-count - 1) {

        // push-/pull-(x) ==> --column-push = x
        .#{$m__}push-#{$n} { --column-push: #{$n}; }
        .#{$m__}pull-#{$n} { --column-push: #{$n*-1}; }

        // push-r-/pull-r-(x) ==> --column-push-r = x
        .#{$m__}push-r-#{$n} { --column-push-r: #{$n}; }
        .#{$m__}pull-r-#{$n} { --column-push-r: #{$n*-1}; }
      }

      @each $span, $pair-list in $span-pair-list {

        // mcol-(x) ==> --multi-column-count = x
        .mcol-#{$span} {
          --multi-column-count: #{$span};
        }

        // TODO: span-min-() --> maintain min of 2 columns, expand to fill.

        // TODO: span-max-() --> maintain max of 2 columns, contract to fill.

        // span-(x) ==> --column-span = x
        .#{$m__}span-#{$span} {
          --column-span: #{$span};
          & > * { --local-column-count: #{$span}; }

          // NB: this is while CSS min() and max() functions are not yet supported
          $span-max: m-var('column-count');
          &.span-safe {
            --column-span: #{min($span, $span-max)};
            & > * { --local-column-count: #{min($span, $span-max)}; }
          }
        }

        // row-span-(y) ==> --row-span = y
        .#{$m__}row-span-#{$span} { --row-span: #{$span}; }

        // span-(x) > *, span-(s)-(e) > * ==> --local-column-count = x
        .#{$m__}span-#{$span},
        #{__map($pair-list, 'm__col-start-to-end')} { & > * { --local-column-count: #{$span}; } }
      }

      @each $start, $pair-list in $start-pair-list {

        // start-(s), col-(s)-() ==> --column-start = s
        .#{$m__}start-#{$start},
        #{__map($pair-list, 'm__col-start-to-end')} { --column-start: #{$start}; }

        // row-start-(x), row-(s)-() ==> --row-start = x
        .#{$m__}row-start-#{$start},
        #{__map($pair-list, 'm__row-start-to-end')} { --row-start: #{$start}; }
      }

      @each $end, $pair-list in $end-pair-list {

        // end-neg-(e)
        .#{$m__}end-neg-#{$end - 1} { --column-end: #{($end - 1)*-1}; }

        // row-end-neg-(e)
        .#{$m__}row-end-neg-#{$end - 1} { --row-end: #{($end - 1)*-1}; }

        // end-(e), col-()-(e) ==> --column-end = e
        .#{$m__}end-#{$end},
        #{__map($pair-list, 'm__col-start-to-end')} { --column-end: #{$end}; }

        // row-end-(x), row-()-(e) ==> --row-end = x
        .#{$m__}row-end-#{$end},
        #{__map($pair-list, 'm__row-start-to-end')} { --row-end: #{$end}; }
      }

    }
  }
}
