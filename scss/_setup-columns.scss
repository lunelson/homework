//            _
//           | |
//   ___ ___ | |_   _ _ __ ___  _ __  ___
//  / __/ _ \| | | | | '_ ` _ \| '_ \/ __|
// | (_| (_) | | |_| | | | | | | | | \__ \
//  \___\___/|_|\__,_|_| |_| |_|_| |_|___/

// $m__: '';

// @function m__col-start-to-end($pair, $index, $list, $m__, $_...) { @return selector-parse('.#{$m__}col-#{nth($pair, 1)}-#{nth($pair, 2)}'); }
// @function m__row-start-to-end($pair, $index, $list, $m__, $_...) { @return selector-parse('.#{$m__}row-#{nth($pair, 1)}-#{nth($pair, 2)}'); }

@mixin homework-setup-columns($max-columns: --max-columns()) {

  // MULTI-COLUMN LAYOUT
  #{base-class('mcol')} {
    column-fill: balance;
    column-width: auto;
    column-count: var(--multi-column-count, 1);
    column-gap: var(--column-gap);
    -webkit-perspective: 1; // create new stacking context; see issues https://caniuse.com/#feat=multicolumn
    & > * {
      column-span: none;
      break-inside: avoid;
      break-before: auto;
      break-after: auto;
      --local-column-count: calc(var(--column-span, var(--column-count)) / var(--multi-column-count, 1));
    }
  }

  // FLEXBOX-FLOW LAYOUT
  #{base-class('flow')} {
    display: flex !important;
    flex-direction: row;
    flex-wrap: wrap;
    width: calc(100% + var(--column-gap)) !important;
    margin-left: calc(var(--column-gap) / -2) !important;
    margin-right: calc(var(--column-gap) / -2) !important;
    margin-top: calc(var(--row-gap) / -2) !important;
    margin-bottom: calc(var(--row-gap) / -2) !important;
    & > * {
      flex: 0 0 auto;
      width: 100%;
      min-width: 0%; // https://css-tricks.com/flexbox-truncated-text/
      min-height: 1px; // prevent collapse (?)
      background-clip: content-box; // so gutters remain clear
      padding-left: calc(var(--column-gap) / 2) !important;
      padding-right: calc(var(--column-gap) / 2) !important;
      padding-top: calc(var(--row-gap) / 2) !important;
      padding-bottom: calc(var(--row-gap) / 2) !important;
    }
  }

  // GRID LAYOUT
  #{base-class('grid')} {
    display: grid !important;
    grid-gap: var(--row-gap) var(--column-gap);
    grid-template-rows: repeat(var(--row-span, var(--row-count, 1)), max-content);
    grid-template-columns: repeat(var(--local-column-count, var(--column-span, var(--column-count))), minmax(0%, 1fr)); // ~= 'min-width: 0%' rule above https://css-tricks.com/flexbox-truncated-text/
    & > * {
      grid-column: span var(--column-span, var(--column-count)) / span var(--column-span, var(--column-count));
      grid-row: span var(--row-span, var(--row-count, 1)) / span var(--row-span, var(--row-count, 1));
    }
  }

  // make the following props *non-cascading*
  *, ::before, ::after {
    --column-push: initial;
    --column-push-r: initial;
    --column-start: initial;
    --column-end: initial;
    --row-start: initial;
    --row-end: initial;
  }

  :root { --column-gap: var(--inner-x); }

  .flow, .grid { --row-gap: var(--inner-y); }

  @each $y in map-keys(inner-y-mods()) {
    .flow-#{$y}, .grid-#{$y} { --row-gap: var(--inner-y-#{$y}); }
  }

  // pre-calculations
  $max-column-count: --max-columns();
  // $span-pair-list: ();
  // $start-pair-list: ();
  // $end-pair-list: ();
  // @for $end from 2 through ($max-column-count + 1) {
  //   @for $start from 1 through ($end - 1) {
  //     $span: ($end - $start);
  //     $span-pair-list: map-merge($span-pair-list, ($span: append(map-get($span-pair-list, $span) or (), ($start $end))));
  //     $start-pair-list: map-merge($start-pair-list, ($start: append(map-get($start-pair-list, $start) or (), ($start $end))));
  //     $end-pair-list: map-merge($end-pair-list, ($end: append(map-get($end-pair-list, $end) or (), ($start $end))));
  //   }
  // }

  @each $m in join((null), map-keys($media)) {
    @include m($m) {

      // contexts: solo, flow, mcol; reset: grid
      #{state-base-class('span', false, $m)} {
        max-width: 100%;
        width: calc((99.99999% + var(--column-gap)) * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)) - var(--column-gap));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          width: calc(99.99999% * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('mcol'), '>')} {
          width: initial; // alt: unset
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          width: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{state-base-class('pull', false, $m)},
      #{state-base-class('push', false, $m)} {
        margin-left: calc((99.99999% + var(--column-gap)) * var(--column-push) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-left: calc(99.99999% * var(--column-push) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-left: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{state-base-class('pull-r', false, $m)},
      #{state-base-class('push-r', false, $m)} {
        margin-right: calc((99.99999% + var(--column-gap)) * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-right: calc(99.99999% * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-right: initial; // alt: unset
        }
      }

      #{state-base-class('start', false, $m)} { grid-column-start: var(--column-start); }
      #{state-base-class('end', false, $m)} { grid-column-end: var(--column-end); }
      #{state-base-class('row-start', false, $m)} { grid-row-start: var(--row-start); }
      #{state-base-class('row-end', false, $m)} { grid-row-end: var(--row-end); }

      // #{base-class('grid')} {
      //   @at-root #{selector-combine(&, state-base-class('start', false, $m), $cmbn: '>')} {
      //     grid-column-start: var(--column-start);
      //   }
      //   @at-root #{selector-combine(&, state-base-class('end', false, $m), $cmbn: '>')} {
      //     grid-column-end: var(--column-end);
      //   }
      //   @at-root #{selector-combine(&, state-base-class('row-start', false, $m), $cmbn: '>')} {
      //     grid-row-start: var(--row-start);
      //   }
      //   @at-root #{selector-combine(&, state-base-class('row-end', false, $m), $cmbn: '>')} {
      //     grid-row-end: var(--row-end);
      //   }
      // }

      // NB: this is set globally so it also affects the functions defined at the top
      // $m__: state-prefix() !global;
      $m__: state-prefix();

      // // context: mcol-only (doesn't work in FF)
      // #{base-class('mcol')} {
      //   & > .#{$m__}span-all {
      //     column-span: all;
      //   }
      // }

      // context: flow-only
      #{base-class('flow')} {
        & > .#{$m__}span-auto {
          flex: 1 1 auto;
          --column-span: 0;
        }
      }

      // @for $n from 1 through ($max-column-count - 1) {

      // }

      @for $n from 1 through $max-column-count {

        // PUSH / PULL

        // push-/pull-(x) ==> --column-push = x
        .#{$m__}push-#{$n} { --column-push: #{$n}; }
        .#{$m__}pull-#{$n} { --column-push: #{$n * -1}; }

        // push-r-/pull-r-(x) ==> --column-push-r = x
        .#{$m__}push-r-#{$n} { --column-push-r: #{$n}; }
        .#{$m__}pull-r-#{$n} { --column-push-r: #{$n * -1}; }

        // SPAN

        // mcol-(x) ==> --multi-column-count = x
        .mcol-#{$n} { --multi-column-count: #{$n}; }

        // EXPERIMENTAL: span-min-() --> maintain min of 2 columns, expand to fill.
        .#{$m__}span-min-#{$n} {
          --column-span: max(#{$n}, var(--column-count));
          & > * { --local-column-count: max(#{$n}, var(--column-count)); }
        }

        // EXPERIMENTAL: span-max-() --> maintain max of 2 columns, contract to fill.
        .#{$m__}span-max-#{$n} {
          --column-span: min(#{$n}, var(--column-count));
          & > * { --local-column-count: min(#{$n}, var(--column-count)); }
        }

        // span-(x) ==> --column-span = x; span-(x) > * ==> --local-column-count = x
        .#{$m__}span-#{$n} {
          --column-span: #{$n};
          & > * { --local-column-count: #{$n}; }

          // NB: this is while CSS min() and max() functions are not yet supported
          $column-count: m-var('column-count');
          &.span-safe {
            --column-span: #{min($n, $column-count)};
            & > * { --local-column-count: #{min($n, $column-count)}; }
          }
        }

        // row-span-(y) ==> --row-span = y
        .#{$m__}row-span-#{$n} { --row-span: #{$n}; }

        // START

        // start-(s), col-(s)-() ==> --column-start = s
        .#{$m__}start-#{$n} { --column-start: #{$n}; }

        // row-start-(x), row-(s)-() ==> --row-start = x
        .#{$m__}row-start-#{$n} { --row-start: #{$n}; }

        // END

        // end-neg-(e)
        .#{$m__}end-neg-#{$n} { --column-end: #{$n * -1}; }

        // row-end-neg-(e)
        .#{$m__}row-end-neg-#{$n} { --row-end: #{$n * -1}; }

        // end-(e), col-()-(e) ==> --column-end = e
        .#{$m__}end-#{$n + 1} { --column-end: #{$n + 1}; }

        // row-end-(x), row-()-(e) ==> --row-end = x
        .#{$m__}row-end-#{$n + 1} { --row-end: #{$n + 1}; }
      }
      // // start, 1 to 12
      // @for $n from 1 through $max-column-count {}
      // // end, 2 through 13
      // @for $n from 2 through $max-column-count + 1 {}

      // @each $span, $pair-list in $span-pair-list {

      //   // mcol-(x) ==> --multi-column-count = x
      //   .mcol-#{$span} { --multi-column-count: #{$span}; }

      //   // TODO: span-min-() --> maintain min of 2 columns, expand to fill.

      //   // TODO: span-max-() --> maintain max of 2 columns, contract to fill.

      //   // span-(x) ==> --column-span = x
      //   // span-(x) > * ==> --local-column-count = x
      //   .#{$m__}span-#{$span} {
      //     --column-span: #{$span};
      //     & > * { --local-column-count: #{$span}; }

      //     // NB: this is while CSS min() and max() functions are not yet supported
      //     $span-max: m-var('column-count');
      //     &.span-safe {
      //       --column-span: #{min($span, $span-max)};
      //       & > * { --local-column-count: #{min($span, $span-max)}; }
      //     }
      //   }

      //   // row-span-(y) ==> --row-span = y
      //   .#{$m__}row-span-#{$span} { --row-span: #{$span}; }

      //   // span-(x) > *, span-(s)-(e) > * ==> --local-column-count = x
      //   #{__map($pair-list, 'm__col-start-to-end', $m__)} { & > * { --local-column-count: #{$span}; } }
      // }

      // @each $start, $pair-list in $start-pair-list {

      //   // start-(s), col-(s)-() ==> --column-start = s
      //   .#{$m__}start-#{$start},
      //   #{__map($pair-list, 'm__col-start-to-end', $m__)} { --column-start: #{$start}; }

      //   // row-start-(x), row-(s)-() ==> --row-start = x
      //   .#{$m__}row-start-#{$start},
      //   #{__map($pair-list, 'm__row-start-to-end', $m__)} { --row-start: #{$start}; }
      // }

      // @each $end, $pair-list in $end-pair-list {

      //   // end-neg-(e)
      //   .#{$m__}end-neg-#{$end - 1} { --column-end: #{($end - 1)*-1}; }

      //   // row-end-neg-(e)
      //   .#{$m__}row-end-neg-#{$end - 1} { --row-end: #{($end - 1)*-1}; }

      //   // end-(e), col-()-(e) ==> --column-end = e
      //   .#{$m__}end-#{$end},
      //   #{__map($pair-list, 'm__col-start-to-end', $m__)} { --column-end: #{$end}; }

      //   // row-end-(x), row-()-(e) ==> --row-end = x
      //   .#{$m__}row-end-#{$end},
      //   #{__map($pair-list, 'm__row-start-to-end', $m__)} { --row-end: #{$end}; }
      // }

    }
  }
}
