//            _
//           | |
//   ___ ___ | |_   _ _ __ ___  _ __  ___
//  / __/ _ \| | | | | '_ ` _ \| '_ \/ __|
// | (_| (_) | | |_| | | | | | | | | \__ \
//  \___\___/|_|\__,_|_| |_| |_|_| |_|___/

// $m__: '';

// @function m__start-end($pair, $index, $list, $m__, $_...) { @return selector-parse('.#{$m__}start-end-#{nth($pair, 1)}-#{nth($pair, 2)}'); }
// @function m__row-start-end($pair, $index, $list, $m__, $_...) { @return selector-parse('.#{$m__}row-start-end-#{nth($pair, 1)}-#{nth($pair, 2)}'); }

@mixin homework-setup-columns($max-columns: --max-columns()) {

  // MULTI-COLUMN LAYOUT
  #{base-class('mcol')} {
    column-fill: balance;
    column-width: auto;
    column-count: var(--multi-column-count, 1);
    column-gap: var(--column-gap);
    perspective: 1; // create new stacking context; see issues https://caniuse.com/#feat=multicolumn
    & > * {
      column-span: none; // will not be used
      // FRAGMENTATION; see https://www.smashingmagazine.com/2019/02/css-fragmentation/
      // break-inside: avoid;
      box-decoration-break: clone;
      break-before: auto;
      break-after: auto;
      orphans: 2;
      widows: 2;
      --local-column-count: calc(var(--column-span, var(--column-count)) / var(--multi-column-count, 1));
    }
  }

  #{base-class('mcol-flow')} {
    margin-top: calc(var(--row-gap) / -2) !important;
    margin-bottom: calc(var(--row-gap) / -2) !important;
    & > * {
      break-inside: avoid;
      padding-top: calc(var(--row-gap) / 2) !important;
      padding-bottom: calc(var(--row-gap) / 2) !important;
    }
  }

  // FLEXBOX-FLOW LAYOUT
  #{base-class('flow')} {
    display: flex !important;
    flex-direction: row;
    flex-wrap: wrap;
    width: calc(100% + var(--column-gap)) !important;
    margin-left: calc(var(--column-gap) / -2) !important;
    margin-right: calc(var(--column-gap) / -2) !important;
    margin-top: calc(var(--row-gap) / -2) !important;
    margin-bottom: calc(var(--row-gap) / -2) !important;
    & > * {
      flex: 0 0 auto;
      width: 100%;
      min-width: 0%; // https://css-tricks.com/flexbox-truncated-text/
      max-width: 100%;
      // min-height: 1px; // prevent collapse (? might be only for float-based)
      background-clip: content-box; // so gutters remain clear
      padding-left: calc(var(--column-gap) / 2) !important;
      padding-right: calc(var(--column-gap) / 2) !important;
      padding-top: calc(var(--row-gap) / 2) !important;
      padding-bottom: calc(var(--row-gap) / 2) !important;
    }
  }

  // GRID LAYOUT
  #{base-class('grid')} {
    display: grid !important;
    grid-gap: var(--row-gap) var(--column-gap);
    grid-template-columns: repeat(var(--local-column-count, var(--column-span, var(--column-count))), minmax(0%, 1fr)); // ~= 'min-width: 0%' rule above https://css-tricks.com/flexbox-truncated-text/
    grid-template-rows: repeat(var(--row-span, var(--row-count, 1)), max-content);
    & > * {
      grid-column: span var(--column-span, var(--column-count)) / span var(--column-span, var(--column-count));
      grid-row: span var(--row-span, var(--row-count, 1)) / span var(--row-span, var(--row-count, 1));
    }
  }

  :root { --column-gap: var(--inner-x); }

  .mcol-flow, .flow, .grid { --row-gap: var(--inner-y); }

  @each $y in map-keys(inner-y-mods()) {
    .mcol-flow-#{$y}, .flow-#{$y}, .grid-#{$y} { --row-gap: var(--inner-y-#{$y}); }
  }

  // $span-pair-list: ();
  // $start-pair-list: ();
  // $end-pair-list: ();
  // @for $end from 2 through ($max-columns + 1) {
  //   @for $start from 1 through ($end - 1) {
  //     $span: ($end - $start);
  //     $span-pair-list: map-merge($span-pair-list, ($span: append(map-get($span-pair-list, $span) or (), ($start $end))));
  //     $start-pair-list: map-merge($start-pair-list, ($start: append(map-get($start-pair-list, $start) or (), ($start $end))));
  //     $end-pair-list: map-merge($end-pair-list, ($end: append(map-get($end-pair-list, $end) or (), ($start $end))));
  //   }
  // }

  // make the following props *non-cascading*
  * {
    --column-push: initial;
    --column-push-r: initial;
    // --column-start: initial;
    // --column-end: initial;
    // --row-start: initial;
    // --row-end: initial;
  }

  @each $m in join((null), map-keys($media)) {
    @include m($m) {

      // contexts: solo, flow, mcol; reset: grid
      #{state-base-class('span', false, $m)} {
        width: calc((99.99999% + var(--column-gap)) * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)) - var(--column-gap));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          width: calc(99.99999% * var(--column-span, var(--column-count)) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('mcol'), '>')} {
          width: initial; // alt: unset
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          width: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{state-base-class('pull', false, $m)},
      #{state-base-class('push', false, $m)} {
        margin-left: calc((99.99999% + var(--column-gap)) * var(--column-push) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-left: calc(99.99999% * var(--column-push) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-left: initial; // alt: unset
        }
      }

      // contexts: solo, flow; reset: grid
      #{state-base-class('pull-r', false, $m)},
      #{state-base-class('push-r', false, $m)} {
        margin-right: calc((99.99999% + var(--column-gap)) * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        @at-root #{selector-insert(base-class('flow'), '>')} {
          margin-right: calc(99.99999% * var(--column-push-r) / var(--local-column-count, var(--column-count)));
        }
        @at-root #{selector-insert(base-class('grid'), '>')} {
          margin-right: initial; // alt: unset
        }
      }

      // #{state-base-class('start-end', false, $m)} { grid-column-start: var(--column-start); grid-column-end: var(--column-end); }
      // #{state-base-class('start', false, $m)} { grid-column-start: var(--column-start); }
      // #{state-base-class('end', false, $m)} { grid-column-end: var(--column-end); }

      // #{state-base-class('row-start-end', false, $m)} { grid-row-start: var(--row-start); grid-row-end: var(--row-end); }
      // #{state-base-class('row-start', false, $m)} { grid-row-start: var(--row-start); }
      // #{state-base-class('row-end', false, $m)} { grid-row-end: var(--row-end); }

      // NB: this is set globally so it also affects the functions defined at the top
      // $m__: state-prefix() !global;
      $m__: state-prefix();

      // // context: mcol-only (doesn't work in FF)
      // #{base-class('mcol')} {
      //   & > .#{$m__}span-all {
      //     column-span: all;
      //   }
      // }

      // context: flow-only
      #{base-class('flow')} {
        & > .#{$m__}span-auto {
          flex: 1 1 auto;
          --column-span: 0;
        }
      }

      @for $n from 1 through $max-columns {

        // PUSH / PULL

        // push-/pull-(x) ==> --column-push = x
        .#{$m__}push-#{$n} { --column-push: #{$n}; }
        .#{$m__}pull-#{$n} { --column-push: #{$n * -1}; }

        // push-r-/pull-r-(x) ==> --column-push-r = x
        .#{$m__}push-r-#{$n} { --column-push-r: #{$n}; }
        .#{$m__}pull-r-#{$n} { --column-push-r: #{$n * -1}; }

        // SPAN

        // mcol-(x) ==> --multi-column-count = x
        .#{$m__}mcol-#{$n} { --multi-column-count: #{$n}; }

        // EXPERIMENTAL: span-min-() --> maintain min of 2 columns, expand to fill.
        .#{$m__}span-min-#{$n} {
          --column-span: max(#{$n}, var(--column-count));
          & > * { --local-column-count: max(#{$n}, var(--column-count)); }
        }

        // EXPERIMENTAL: span-max-() --> maintain max of 2 columns, contract to fill.
        .#{$m__}span-max-#{$n} {
          --column-span: min(#{$n}, var(--column-count));
          & > * { --local-column-count: min(#{$n}, var(--column-count)); }
        }

        // span-(x) ==> --column-span = x; span-(x) > * ==> --local-column-count = x
        .#{$m__}span-#{$n} {
          --column-span: #{$n};
          & > * { --local-column-count: #{$n}; }

          // NB: this is while CSS min() and max() functions are not yet supported
          $column-count: m-var('column-count');
          &.span-safe {
            --column-span: #{min($n, $column-count)};
            & > * { --local-column-count: #{min($n, $column-count)}; }
          }
        }

        // row-span-(y) ==> --row-span = y
        .#{$m__}row-span-#{$n} { --row-span: #{$n}; }

        // START / END
        // TODO; add start-end-(s)-(e) variants

        // start-(s), col-(s)-() ==> grid-column-start = s
        .#{$m__}start-#{$n} { grid-column-start: #{$n}; }

        // row-start-(x), row-(s)-() ==> grid-row-start = x
        .#{$m__}row-start-#{$n} { grid-row-start: #{$n}; }

        // END

        // end-neg-(e)
        .#{$m__}end-neg-#{$n} { grid-column-end: #{$n * -1}; }

        // row-end-neg-(e)
        .#{$m__}row-end-neg-#{$n} { grid-row-end: #{$n * -1}; }

        // end-(e), col-()-(e) ==> grid-column-end = e
        .#{$m__}end-#{$n + 1} { grid-column-end: #{$n + 1}; }

        // row-end-(x), row-()-(e) ==> grid-row-end = x
        .#{$m__}row-end-#{$n + 1} { grid-row-end: #{$n + 1}; }
      }
    }
  }
}
