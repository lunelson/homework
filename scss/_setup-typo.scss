//  _
// | |
// | |_ _   _ _ __   ___
// | __| | | | '_ \ / _ \
// | |_| |_| | |_) | (_) |
//  \__|\__, | .__/ \___/
//       __/ | |
//      |___/|_|

// f, trim -- implicitly repsonsive
// `.caps` (and `.smcp`) co-class(es) for `.f-` classes, with different spacing

@mixin homework-setup-typo( $trim: true, $trim-excludes: div table figure img svg video iframe object section aside header footer article ) {

  // normalize $fonts
  $fonts: if(length($fonts) > 0, $fonts, $fonts-defaults) !global;
  @each $f, $font in $fonts {
    $font: map-merge($font-default, $font);
    $fonts: map-merge($fonts, ($f: $font)) !global;
  }

  // $sel-f: '';
  // $sel-stack-f: '';
  // $sel-stack-f-sibling: '';
  // $sel-f-adjacent: '';
  // $sel-plain-el: '';
  // $sel-plain-dir-el: '';
  // $sel-plain-dir-el-sibling: '';
  // $sel-plain-el-adjacent: '';

  // #{base-class('f', false)} {
  //   $sel-f: &;
  //   @at-root #{selector-insert(base-class('stack'), '>')} { $sel-stack-f: &; }
  //   @at-root #{selector-insert(base-class('stack'), '> * +')} { $sel-stack-f-sibling: &; }
  //   @at-root #{selector-insert(selector-last(), '+')} { $sel-f-adjacent: &; }
  // }

  // #{base-class('plain')} {
  //   #{selector-not('*', $trim-excludes)} { $sel-plain-el: &;
  //     @at-root #{selector-insert('>')} { $sel-plain-dir-el: &; }
  //     @at-root #{selector-insert('> * +')} { $sel-plain-dir-el-sibling: &; }
  //     @at-root #{selector-insert(selector-last(), '+')} { $sel-plain-el-adjacent: &; }
  //   }
  // }

  // .test {
  //   sel-f: inspect($sel-f);
  //   sel-stack-f: inspect($sel-stack-f);
  //   sel-stack-f-sibling: inspect($sel-stack-f-sibling);
  //   sel-f-adjacent: inspect($sel-f-adjacent);
  //   sel-plain-el: inspect($sel-plain-el);
  //   sel-plain-dir-el: inspect($sel-plain-dir-el);
  //   sel-plain-dir-el-sibling: inspect($sel-plain-dir-el-sibling);
  //   sel-plain-el-adjacent: inspect($sel-plain-el-adjacent);
  // }


  :root {
    @each $f, $font in $fonts {

      $ff: map-get($font, 'font-family');
      $lh: map-get($font, 'line-height');
      $ls: map-get($font, 'letter-spacing');
      $ffs: map-get($font, 'font-feature-settings');
      --font-family-#{$f}: #{$ff};
      --font-feature-settings-#{$f}: #{inspect($ffs)};
      --line-height-#{$f}: #{decalc($lh)};
      --letter-spacing-#{$f}: #{decalc($ls)};

      @if $trim {
        $ts: map-get($font, 'trim-sides');
        $oc: map-get($font, 'offset-capline');
        $ob: map-get($font, 'offset-baseline');
        $aa: map-get($font, 'adjust-adjacent');
        --trim-sides-#{$f}: #{$ts};
        --offset-capline-#{$f}: #{if(unitless($oc), $oc*1em, $oc)};
        --offset-baseline-#{$f}: #{if(unitless($ob), $ob*1em, $ob)};
        --adjust-adjacent-#{$f}: #{decalc($aa)};
      }

    }

    // NOTE: alternate method here would be min-width queries with m-orig-var(font-mods)
    // ...(less code but more runtime work)
    @include mm-for('font-mods') {
      @each $f, $mod in m-var('font-mods') {
        @each $s, $set in $mod {
          $fz: nth($set, 1);
          $fz: if(unitless($fz), $fz*1px, $fz);
          // TODO: make it possible to pass calc as this value too
          --font-size-#{$f}-#{$s}: #{$fz};
          $lh: if(length($set) > 1, nth($set, 2), null);
          @if $lh {
            $lh: if(unitless($lh), if($lh > 6, $lh*1px, $lh*1em), $lh);
            // TODO: make it possible to pass calc as this value too
            --line-height-#{$f}-#{$s}: #{$lh};
          }
        }
      }
    }
  }
  // TODO: place these defaults in homework-reset
  body {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    font-kerning: normal;
    font-family: map-get($fonts, nth(map-keys($fonts), 1), 'family');
  }

  // font weights
  // @each $n in (1 2 3 5 6 8 9) { .fw-#{$n*100} { font-weight: $n*100; } }
  .fw-700, .fw-bold, .strong { font-weight: bold; }
  .fw-400, .fw-normal { font-weight: normal; }

  // font-styles; NB: there is also 'oblique' but I've never seen it in use
  .fs-italic, .em { font-style: italic; }
  .fs-normal { font-style: normal; }

  // any .f-[f]-[s] plus common inline elements
  // NOTE still not sure if this is the right idea
  #{base-class('f', false)} {
    @at-root &, i, b, em, strong, a, code, var, data, dfn, kbd, mark, q, small, sub, sup, cite, abbr {
      font-family: var(--font-family);
      font-feature-settings: var(--font-feature-settings);
      font-size: var(--font-size); // TODO allow a lerp calc() expression here too
      line-height: calc(var(--line-height)); // NB using calc(var()) because these are raw calc values
      letter-spacing: calc(var(--letter-spacing)); // NB using calc(var()) because these are raw calc values
    }
    @if $trim {
      @at-root #{selector-insert(base-class('stack'), '>')} {
        --trim-top: calc((var(--line-height) - 1em) / 2 + var(--offset-capline) + var(--trim-top-adjust));
        --trim-bottom: calc((var(--line-height) - 1em) / 2 + var(--offset-baseline));
        --trim-top-adjust: 0%;
        margin-top: calc(0% - var(--trim-top));
        margin-bottom: calc(0% - var(--trim-bottom));
        margin-right: var(--trim-sides);
        margin-left: var(--trim-sides);
      }
      @at-root #{selector-insert(base-class('stack'), '> * +')} {
        margin-top: subtract(var(--stack-gap), var(--trim-top));
      }
      @at-root #{selector-insert(selector-last(), '+')} {
        --trim-top-adjust: var(--adjust-adjacent, 0%);
      }
    }
  }

  @each $f, $font in $fonts {

    #{base-class('f-#{$f}')} {
      --font-family: var(--font-family-#{$f});
      --line-height: var(--line-height-#{$f});
      --letter-spacing: var(--letter-spacing-#{$f});
      --font-feature-settings: var(--font-feature-settings-#{$f});

      @if $trim {
        $ts: map-get($font, 'trim-sides');
        $tc: map-get($font, 'offset-capline');
        $tb: map-get($font, 'offset-baseline');
        $aa: map-get($font, 'adjust-adjacent');
        @if $ts { --trim-sides: #{$ts}; }
        @if $tc { --offset-capline: #{if(unitless($tc), $tc*1em, $tc)}; }
        @if $tb { --offset-baseline: #{if(unitless($tb), $tb*1em, $tb)}; }
        @if $aa { --adjust-adjacent: #{decalc($aa)}; }
      }
    }
  }

  @if $trim {
    #{base-class('plain')} {
      #{selector-not('*', $trim-excludes)} {
        font-family: var(--font-family);
        font-feature-settings: var(--font-feature-settings);
        font-size: var(--font-size); // TODO allow a lerp calc() expression here too
        line-height: calc(var(--line-height)); // NB using calc(var()) because these are raw calc values
        letter-spacing: calc(var(--letter-spacing)); // NB using calc(var()) because these are raw calc values
        @if $trim {
          @at-root #{selector-insert('>')} {
            --trim-top: calc((var(--line-height) - 1em) / 2 + var(--offset-capline) + var(--trim-top-adjust));
            --trim-bottom: calc((var(--line-height) - 1em) / 2 + var(--offset-baseline));
            --trim-top-adjust: 0%;
            margin-top: calc(0% - var(--trim-top));
            margin-bottom: calc(0% - var(--trim-bottom));
            margin-right: var(--trim-sides);
            margin-left: var(--trim-sides);
          }
          @at-root #{selector-insert('> * +')} {
            margin-top: subtract(var(--stack-gap), var(--trim-top));
          }
          @at-root #{selector-insert(selector-last(), '+')} {
            --trim-top-adjust: var(--adjust-adjacent, 0%);
          }
        }
      }
    }
  }

  @each $f, $mod in map-get($root, 'font-mods') {
    @each $s, $set in $mod {
      .f-#{$f}-#{$s} {
        --font-size: var(--font-size-#{$f}-#{$s});
        --line-height: var(--line-height-#{$f}-#{$s}, var(--line-height-#{$f}));
        // --letter-spacing: var(--letter-spacing-#{$f}-#{$s}, var(--letter-spacing-#{$f}));
      }
    }
  }

}
