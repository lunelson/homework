//  _
// | |
// | |_ _   _ _ __   ___
// | __| | | | '_ \ / _ \
// | |_| |_| | |_) | (_) |
//  \__|\__, | .__/ \___/
//       __/ | |
//      |___/|_|

@import 'support/typo-support';

@mixin setup-typo {

  :root {
    --font-family: sans-serif; // should be first font
    --font-size: 1rem;
    --line-height: 1.25;
    --trim-x: 0;
    --trim-top: 0;
    --trim-bottom: 0;
    --trim-capline: 0;
    --trim-xline: 0;
    --trim-baseline: 0;
  }

  #{base-class('sans')},
  #{base-class('serif')} {
    font-family: --font-family;
    font-size: --font-size;
    line-height: --line-height;
    #{base-class('stack')} > &, &.trim {
      margin-top: calc(0px);
      margin-bottom: calc(0px);
      margin-right: --trim-x;
      margin-left: --trim-x;
    }
    #{base-class('stack')} > * + & {
      margin-top: calc(var(--stack-gap));
    }
  }

  @each $f, $font in map-get($root, 'font-alts') or () {
    @each $s, $def in $font {
      .#{$f}--#{$s} {
        --font-size: --font-size--#{$f}--#{$s};
        --line-height: --line-height--#{$f}--#{$s};
      }
    }
  }

  // if length of fonts is 0, merge fonts-default against it;
  $fonts: if(length($fonts) > 0, $fonts, $fonts-defaults) !global;

  // if $body-font name is unset, take the first font key in $fonts
  $body-font: $body-font or nth(map-keys($fonts), 1) !global;

  // merge each font against font-default; merge result back to $fonts
  @each $f, $font in $fonts {
    $font: map-merge($font-default, $font);
    $fonts: map-merge($fonts, ($f: $font)) !global;
  }

  body, body * { @include font($body-font); }

  //
  // LOOP: FONTS
  //

  @each $f, $font in $fonts {

    #{base-class($f)} {

      // base definition
      @include font($f);

      // trim-x conditions
      $trim-x: map-get-z($fonts, $f, 'trim-x');
      @if $trim-x and $trim-x != 0 {
        $is-trim-x: selector-parse('&.trim-x');
        $is-in-stack: insert-parents(base-class('stack'), '>');
        @at-root #{$is-trim-x}, #{$is-in-stack} {
          margin-right: $trim-x;
          margin-left: $trim-x;
        }
      }
    }

    //
    // LOOP: typos
    //

    $typos: m-var('typos' $f, null); // from $root
    @if $typos {
      @each $t in map-keys($typos) {

        //
        // MEDIA FOR: copy size, font
        //
        @include mm-for('typos' $f $t) {
          $typo: m-var('typos' $f $t);
          $px-base: strip(m-var('font-size'));
          $px-size: nth($typo, 1);
          $line: nth($typo, 2);

          #{mod-class($f, $t, '')} {
            font-size: $px-size / $px-base * 1rem;
            line-height: $line;

            //
            // TRIM: top/bottom wrt .stack
            //
            $is-trim: selector-parse('&.trim');
            $is-in-stack: insert-parents(base-class('stack'), '>');
            @at-root #{$is-trim}, #{$is-in-stack} {
              margin-top: trim-top-margin(0, $line, $f);
              margin-bottom: trim-bottom-margin(0, $line, $f);
            }
          }
        }

        //
        // LOOP: INNER-Y
        //

        $inner-y: m-var('inner-y', null); // from $root
        // $y-map: if(type-of($inner-y) == 'map', $inner-y, (m: $inner-y));
        $y-keys: if(type-of($inner-y) == 'map', map-keys($inner-y), (m));
        @each $y in $y-keys {
          $y-path: if(type-of($inner-y) == 'map', 'inner-y' $y, 'inner-y');

          //
          // MEDIA-FOR: inner-y || copy-size, font
          //
          @include mm-for($y-path, 'typos' $f $t) {
            $typo: m-var('typos' $f $t);
            $px-base: strip(m-var('font-size'));
            $px-size: nth($typo, 1);
            $line: nth($typo, 2);

            // stack--[mult] mod-class
            @at-root #{mod-class('stack', $y, 'm')} {

              // direct-child font--[size] mod-class
              & > *:not(.unstack) + #{mod-class($f, $t, '')} {

                // trimmed margin-top value
                margin-top: trim-top-margin($y, $line, $f);
              }
            }

          }
        }

      }
    }
  }

}
